
create or replace procedure updateOtps(
	sender varchar,
	sotp varchar
)
language plpgsql    
as $$
begin
    update users
    set otp = sotp,
	 updated_at = (SELECT CAST(EXTRACT(epoch FROM CURRENT_TIMESTAMP) * 1000 AS BIGINT))
    where email = sender;
    commit;
end;$$

CREATE OR REPLACE PROCEDURE LastInsertUser()
LANGUAGE plpgsql    
AS $$
DECLARE
    last_user users%ROWTYPE;  -- Declaring a variable to hold the last user
BEGIN
    SELECT * INTO last_user FROM users ORDER BY id DESC LIMIT 1;
    RAISE NOTICE 'Last User: %', last_user;
    COMMIT;
END;
$$


CREATE OR REPLACE FUNCTION insert_update_users(
    p_users_data userdata[]
)
RETURNS TABLE (
    first_name VARCHAR(100),
    user_email VARCHAR(100),
    user_mobile VARCHAR(20)
    
) AS $$
DECLARE
    user_information usersdata;
    user_data_record usersdata;
BEGIN
    FOR user_data_record IN SELECT * FROM UNNEST(p_users_data) AS t
    LOOP
        IF EXISTS(SELECT 1 FROM users WHERE email = user_data_record.user_email) THEN
            UPDATE users
            SET 
                first_name = user_data_record.first_name,
                -- last_name = user_data_record.last_name,
                email = user_data_record.user_email,
                -- password = user_data_record.password,
                mobile = user_data_record.user_mobile
            WHERE email = user_data_record.user_email;
        ELSE
            INSERT INTO users (first_name, email, mobile)
            VALUES (user_data_record.first_name,
                    -- user_data_record.last_name, 
                    user_data_record.user_email, 
                    -- user_data_record.password, 
                    user_data_record.user_mobile)
            RETURNING user_data_record.first_name AS first_name, 
                      user_data_record.email AS user_email,
                      user_data_record.user_mobile AS user_mobile
            INTO user_information;

            RETURN NEXT;
        END IF;
    END LOOP;
END;
$$ LANGUAGE plpgsql;

SELECT * FROM insert_update_users(ARRAY[
    ROW('John', 'john@example.com', '1234567890'::VARCHAR),
    ROW('Jane', 'jane@example.com', '9876543210'::VARCHAR)
]::userdata[]);
-- drop table if exists accounts;

-- create table accounts (
--     id int generated by default as identity,
--     name varchar(100) not null,
--     balance dec(15,2) not null,
--     primary key(id)
-- );

-- insert into accounts(name,balance)
-- values('Bob',10000);

-- insert into accounts(name,balance)
-- values('Alice',10000);


-- create or replace procedure transfer(
--    sender int,
--    receiver int, 
--    amount dec
-- )
-- language plpgsql    
-- as $$
-- begin
--     -- subtracting the amount from the sender's account 
--     update accounts 
--     set balance = balance - amount 
--     where id = sender;

--     -- adding the amount to the receiver's account
--     update accounts 
--     set balance = balance + amount 
--     where id = receiver;

--     commit;
-- end;$$

-- call transfer(1,2,1000);

-- select * from accounts;

-- create [or replace] procedure procedure_name(parameter_list)
-- language plpgsql
-- as $$
-- declare
-- -- variable declaration
-- begin
-- -- stored procedure body
-- end; $$

-- Table accounts as A {
--   id bigint [pk]
--   owner varchar [not null]
--   balance  bigint [not null]
--   currency varchar [not null]
--   created_at timestamp 

--   Indexes{
--     owner
--   }
  
-- }

-- Table entries {
--   id bigint [pk]
--   account_id bigint [ref: > A.id]
--   amount bigint [not null, note: "it can be nagetive or positive"]
--   created_at timestamp 

--   Indexes{
--     account_id
--   }
-- }

-- Table transfers {
--   id bigint [pk]
--   from_account_id bigint [ref: > A.id]
--   to_account_id bigint [ref: > A.id]
--   amount bigint [not null, note: "must be positive"]
--   created_at timestamp

--   Indexes{
--     from_account_id
--     to_account_id
--     (from_account_id, to_account_id)
--   }
-- }

-- CREATE OR REPLACE FUNCTION insert_update_users(
--     p_users_data users_datas[]
-- )
-- RETURNS TABLE (
--     user_id INT,
--     user_name VARCHAR(255),
--     user_email VARCHAR(255)
-- ) AS $$
-- DECLARE
--     user_information user_datas;
--     user_data_record users_datas;
-- BEGIN
--     FOREACH user_data IN SELECT * FROM ARRAY p_users_data 
--     LOOP
--         IF EXISTS(SELECT 1 FROM users WHERE user_fun_id = user_data.user_id) THEN
--             UPDATE users_func
--             SET 
--                 first_name = user_data.first_name,
--                 last_name = user_data.last_name,
--                 email = user_data.email,
--                 password = user_data.password,
--                 mobile = user_data.mobile
--             WHERE user_fun_id = user_data.user_id;
--         ELSE
--             INSERT INTO users_func (first_name, last_name, email, password, mobile)
--             VALUES (user_data.first_name, user_data.last_name, user_data.email, user_data.password, user_data.mobile)
--             RETURNING user_fun_id AS user_id, 
--                       CONCAT(first_name, ' ', last_name) AS user_name, 
--                       email AS user_email 
--             INTO user_information;
--         END IF;
        
--         RETURN NEXT;
--     END LOOP;
-- END;
-- $$ LANGUAGE plpgsql; 
